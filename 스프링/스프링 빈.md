# 스프링 빈

## 스프링 빈이란?
- 스프링 컨테이너에서 관리하는 객체
- 한 번만 생성하고, 이 때 의존성 주입을 같이 함

## 빈 스코프
### singleton
- DI 컨테이너를 기동할 때 빈 인스턴스 하나가 만들어진다. 이후부터 그 인스턴스를 공유한다.

### prototype
- DI 컨테이너에 빈을 요청할 때마다 새로운 빈 인스턴스가 만들어진다.
- **value를 가지고 있고 멀티스레드 환경**에서 오동작이 발생하지 않아야한 thread-safe 빈이라면 싱글톤이 아닌 프로토타입을 사용해야 한다.

### request
- **HTTP 요청이 들어올 때마다 새로운 빈 인스턴스가** 만들어진다.
- 웹 애플리케이션을 만들때만 사용 가능

### session
- **HTTP 세션이 만들어질 때**마다 새로운 빈 인스턴스가 만들어진다.
- 웹 어플리케이션을 만들 때만 사용할 수 있다.

### application
- **서블릿 컨텍스트가 만들어질 때**마다 빈 인스턴스가 만들어진다
- 웹어플리케이션을 만들 때만 사용

### custom
- **스코프 이름을 직접 정하고 정의한 규칙에 따라** 빈 인스턴스를 만들 수 있다.
- DI 컨테이너에 등록된 빈은 빈 스코프가 싱글톤이다. 즉 DI 컨테이너에서 빈을 가져오려 할 때 같은 것이 없으면 새로 만들고 있으면 만들어진 것을 공유한다. 그리고 컨테이너가 파괴되면 그 안의 빈도 같이 파괴된다.

## 라이프사이클

- 생성
- 빈 초기화
  1. 빈 설정
  2. 빈 인스턴스화, 의존성 주입
  3. 빈 생성, 후처리
- 빈 사용
- 빈 종료(소멸)
  - DI 컨테이너가 역할을 다하고 파괴될 때가 되면 그 안의 빈도 파괴되는 절차를 밝게 된다.
  - 경우에 따라 파괴되기 전 마지막으로 처리해야하는 작업이 있을 수 있는데
  - 스프링 프레임워크에서 빈이 파괴되기 전 전처리 할 수 있는 방법을 제공한다
    - PreDestroy

- 스프링컨테이너의 라이프사이클과 빈 라이프사이클 
  * **스프링 컨테이너 생성:** 애플리케이션이 시작될 때, 스프링 컨테이너가 생성
  * **빈 정의 및 생성:** 빈 정의 정보를 바탕으로 빈 객체들을 생성
  * **의존성 주입:** 생성된 빈들 간의 의존성 주입
  * **빈 사용:**
  * **컨테이너 소멸:** 애플리케이션이 종료될 때, 스프링 컨테이너도 종료되며 빈들의 소멸 메서드가 호출

- 스프링 빈 라이프사이클 지원 방법
  - Spring 인터페이스
  - @PostConstruct, @PreDestroy
  - @Bean 어노테이션에 속성을 추가

- 주입할 수 있는 빈이 두 개 이상이 된다면?
  - 우선순위를 설정한다. `@Primary`같이
  - `@Qulifier`를 사용하여 원하는 빈을 주입할 수 있다.


### 싱글톤 빈은 스레드로부터 안전할까?
- value를 가지지 않으면 된다.
- 어떤 Thread에서는 수정하고 어떤 Thread에서는 가져올 때 이 값이 매번 바뀔 수 있다.
- 스프링 빈을 상태를 변경할 수 있게 만든다면, Thread-safe 하지 않다.
- 빈을 싱글톤으로 관리하지 않는다면 어떤 문제점이 발생할까?
  - 스프링이 주로 적용되는 대상이 **자바 엔터프라이즈 기술을 사용하는 서버환경**
    - 대규모 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십~수백 번씩 브라우저나 여러 시스템으로부터 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경
    - 또한 하나의 요청을 처리하기 위해 데이터 액세스 로직, 서비스 로직 등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조
    - 요청이 올 때마다 모든 오브젝트를 새로 만들어서 사용한다면 서버가 감당하기 힘들 것. 이렇게 애플리케이션에서 제한된, 수 대개 한 개의 오브젝트만 만들어 사용하는 것이 싱글톤 패턴의 원리
  - 정리하면, 다음과 같은 문제가 발생한다.
    1. 자원 낭비: 객체의 생성과 소멸에 대한 오버헤드가 발생. 메모리 사용량과 객체 생성 시간이 증가
    2. 의존성 관리의 어려움: 각각의 인스턴스가 독립적으로 생성되기 때문에 의존성 관리가 어려워진다. 의존하는 다른 빈들이 각각의 인스턴스를 참조해야 하기 때문에 복잡해진다.

### 싱글톤을 자바로 구현했을 때 한계점, 해결 방안
#### 한계점
1. private 생성자를 갖고 있어 상속할 수 없다.
   싱글톤 패턴은 생성자를 private으로 제한한다. 오직 싱글톤 클래스 자신만이 자기 오브젝트를 만들도록 제한한다. 문제는 private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다는 것이다. 또한 상속과 다형성 같은 객체지향의 특징이 적용되지 않는 static 필드와 메소드를 사용하는 것도 역시 동일한 문제를 발생시킨다.

2. 싱글톤은 테스트하기 힘들다.
   싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 Mock 오브젝트 등으로 대체하기가 힘들다. 싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트를 직접 만들어 사용할 수밖에 없다.

3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
   서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다. 자바를 이용한 싱글톤 패턴 기법은 여러 개의 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤이 꼭 보장된다고 할 수 없다.

4. 싱글톤 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
   싱글톤은 사용하는 클라이언트가 정해져 있지 않다. 싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될 수 있고, 그러다 보면 자연스럽게 전역 상태로 사용되기 쉽다. 전역 상태는 객체지향 프로그래밍에서 권장되지 않는다.

#### 해결 방안: 싱글톤 레지스트리
- 스프링은 싱글톤 레지스트리라는 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공.
- 싱글톤 레지스트리의 장점은 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점
- 싱글톤 레지스트리 덕분에 애플리케이션 클래스라도 public 생성자를 가질 수 있으며 테스트하기도 편리해진다. 
- 싱글톤 패턴과 달리 객체지향적 설계 방식과 원칙을 적용하는데 제약이 없다
- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있으므로 상태정보를 내부에 갖고 있지 않는 **Stateless** 방식으로 만들어져야 한다. 
- 저장 공간이 하나뿐이므로 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다. 
- Stateless 방식으로 클래스를 만들기 위해 각 요청에 대한 정보나 DB나 서버의 리소스로 부터 생성한 정보는 **파라미터와 로컬 변수, 리턴 값** 등을 이용해 관리해줘야 한다. **내부에서 생성**되는 변수는 매번 새로운 값을 저장할 공간이 만들어지므로 Stateless하게 관리될 수 있다.
- 스프링 컨테이너가 싱글톤 레지스트리의 역할을 한다.


#### 참고 글
[스프링은 빈을 왜 싱글톤으로 생성할까?](https://velog.io/@minwest/Spring-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%80-%EB%B9%88%EC%9D%84-%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%A0%EA%B9%8C)
